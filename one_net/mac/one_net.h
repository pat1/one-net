#ifndef _ONE_NET_H
#define _ONE_NET_H

#include "config_options.h"
#include "one_net_message.h"


//! \defgroup ONE-NET ONE-NET
//! @{

/*
    Copyright (c) 2010, Threshold Corporation
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

        * Redistributions of source code must retain the above copyright notice,
          this list of conditions, and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
        * Neither the name of Threshold Corporation (trustee of ONE-NET) nor the
          names of its contributors may be used to endorse or promote products
          derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
    CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
    OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
    BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHEWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*!
    \file ONE_NET.h
    \brief ONE-NET declarations.

    Basis for ONE-NET.  Everything in this file is application independent
    (including independent from being a MASTER or a CLIENT).  The only places
    these functions should be called from is in one_net_master.c &
    one_net_client.c.
    
    \note These functions SHOULD NOT be called by any application code!
    
    \note Below are compile time options that can be used to control the type
    of build created.

    ONE-NET compile time options<br>
    Currently (version 1.5.0 and earlier), ONE-NET used the Renesas HEW IDE to specify 
    compile time options. In the future, we plan to move these options into an include
    file so that building ONE-NET is less dependent on the IDE being used.
    In the meantime, below are explanations of some of the compile time options for 
    controlling the type of load that is built.

    _EVAL_0005_NO_REVISION<br>
    This option is used to build a ONE-NET eval board load for the older eval board
    ware. This older hardware had a part number of 0005 where newer eval boards
    have part numbers of the form 06-0005-XX where XX is a revision number. The oder
    0005 board layout mapped the user pins to different processor pins than the newer
    eval boards.

    _ENABLE_DUMP_COMMAND<br>
    This option causes the dump command to be included in the CLI. The dump command
    was used during development of code that accesses data flash. 

    _ENABLE_LIST_COMMAND<br>
    This option causes the list command to be included in the CLI. The list command was added 
    to the CLI to supply information about the current network and i/o pin configuration. 

    _CLOCK_OUT_DIVIDE_BY_TWO<br>
    This option is used to build a version that modifies the frequency of the 
    clock generated by the ADF7025 to make it easier to tune the RF section
    of the circuit.

    _ONE_NET_TEST_NACK_WITH_REASON_FIELD<br>
    This option should only be used when generating a test load for the ONE-NET eval
    board. The test load generated when this option is specified will send the new
    NACK with reason field instead of the basic NACK message. This was needed to help
    ensure that version 1.5.0 of ONE-NET will continue to communicate with devices in
    in the future running ONE-NET code that uses the NACK with reason field message
    in place of the basic NACK message included in versions of ONE-NET up through 
    and including 1.5.0. Removed from the code in 1.5.1.

    _ONE_NET_DEBUG<br>
    This option can be used to turn on debugging of low level ONE-NET operations.
    For example, when used on an eval board load, debugging information will be
    sent to the UART. Since the eval board is very tight on program memory, you
    may need to disable some features such as CLI commands in order to make room
    for the additional debugging code. The baud rate of the serial port is increased 
    to 115,200 bps with this option so that debug information has as little impact
    as possible on performance.

    _ENABLE_RSINGLE_COMMAND<br>
    This option enables the rsingle command. It can be used to
    to send multiple single messages. The syntax of the rsingle
    command is the same as the syntax of the single command. The only difference is
    the rsingle command will send the single data message 20 times waiting approximately
    1 second between each message.

    _ENABLE_RSSI_COMMAND<br>
    This option enables the rssi commmand. The rssi command constantly monitors the RSSI
    reading from the ADF7025 transceiver using the read_rssi() funtion. Once this command
    is executed it runs continuously. The board must be reset to stop the command. 
    Approximately every 16 ticks this command prints the raw RSSI value in hex,
    followed my bits 4 through 11 of the tick count, followed by 50 C or B charcters
    representing whether the channel is clear (C) or busy (B). The example below
    was recorded just after an invite command was issued. The channel command should
    be used to make sure the eval board running the rssi command is listening to the
    correct channel.
    <code>
    rssi=FFA2 90 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA3 A1 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA3 B2 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBCCCCCC<br>
    rssi=FFA4 C3 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBCCCCCCCCC<br>
    rssi=FFA5 D4 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA0 E5 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA4 F6 CCCCCCCCCCCCCCCCCCCCCCCCCCBBBCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA3 07 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA1 18 CCCCCCCCCCCCCCCCCBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA2 29 CCCCCCCCCCCCCCBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA6 3A CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA2 4B CCCCCBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    rssi=FFA5 5C CCBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC<br>
    </code>

    _ONE_NET_DEBUG_STACK<BR>
    This option can be used to help determine how much of the normal stack is being used.
    The stack analysis tools provided by Rensas analyze stack usage but ONE_NET code
    makes us of pointers to functions which cannot be factored into the static analyses
    performed my the Renesas utilities.

    _ENABLE_CLIENT_PING_RESPONSE<BR>
    This option can be used to enable a automatic response to a ping message from 
    a master. A "ping" message in this context is a single data message with a 
    payload type of ONA_SIMPLE_TEXT where the two text charaters are "pi". With
    this option enabled, a client hearing a single data ONA_SIMPLE_TEXT message with 
    a payload of "pi" will send a single data ONA_SIMPLE_TEXT message with a 
    payload of "ng" to the master.

*/

#include "one_net_status_codes.h"
#include "one_net_types.h"
#include "one_net_xtea.h"


//==============================================================================
//                                  CONSTANTS
//! \defgroup ONE-NET_const
//! \ingroup ONE-NET
//! @{

//! ONE-NET Version numbers<br>
//! There are two types of ONE-NET vesion numbers. One set of version numbers is used
//! to identify a release of the ONE-NET source code. There are three levels to this
//! source code release version number, major, minor, and revision. These version numbers
//! appear in the one_net.h file as the three #defines ONE_NET_VERSION_MAJOR, ONE_NET_VERSION_MINOR,
//! and ONE_NET_VERSION_REVISION. For example, the source code that was released on CD at Rensas
//! DevCon on 10/13/08 was labeled as ONE_NET_SRC_V1_3_7.zip. This filename was constructed
//! based on the ONE-NET source code release version numbers of 1.3.7 (major=1, minor=3,
//! revision=7). 
//! There is a second type of ONE-NET version number named ON_VERSION. This is a one byte
//! version number which is really a ONE-NET protocol version number. This version number is
//! included in Status Response basic administrative message and is used to verfiy that the
//! master and client are communicating with compatible versions of the ONE-NET protocol.
//! Ideally, we would have only one ONE-NET version number and use that to determine both
//! the source code release version and the ONE-NET protocol compatibility. But ONE-NET 
//! efficiency requires that we use as small a number as possible for the protocol compatibility
//! number so we use one byte. We do not expect this ONE-NET compatibilty version number to 
//! change very often. However, one byte is not sufficient to represent the number of
//! iterations we expect to have for ONE-NET source code. So, we end up with two different
//! ONE-NET version numbers. Most people will be using the source code release version number
//! to identify releases of ONE-NET most of the time. 
//! In order to facilitate final testing of a release candidate, we also include have a 
//! ONE_NET_VERSION_BUILD number. This number will be inremented when a new load is put
//! on any piece of hardware. When a particular load has completed pre-release testing,
//! the build number for the load that was tested becomes the build number for the release.


enum {
    ONE_NET_VERSION_MAJOR =     2,  //! ONE-NET major version number
    ONE_NET_VERSION_MINOR =     0,  //! ONE-NET minor version number
    ONE_NET_VERSION_REVISION =  1,  //! ONE-NET revision version number
    ONE_NET_VERSION_BUILD =     100  //! ONE-NET build version number
};


enum
{
    ON_VERSION = 0x05,

    //! The version of the on_base_param_t, on_master_param_t, client_t,
    //! on_master_t and on_peer_t structures
    ON_PARAM_VERSION = 0x0003,

    //! The version of the MASTER Invite New CLIENT packet.
    ON_INVITE_PKT_VERSION = 0x00,

    //! The maximum number of times to try a transaction
    ON_MAX_RETRY = 8,

    #ifdef _DATA_RATE
    //! The number of times to send a data rate test packet when performing a
    //! data rate test
    ON_MAX_DATA_RATE_TRIES = 8,
    #endif

    //! The max nonce
    ON_MAX_NONCE = 63,

    //! Value to use to mark an invalid nonce
    ON_INVALID_NONCE = 0xFF,

    //! The maximum number of hops
    ON_MAX_HOPS_LIMIT = 7,

    //! Represents an invalid hops value
    ON_INVALID_HOPS = ON_MAX_HOPS_LIMIT + 1,

    //! The number of hops to try when sending the first Multi-Hop packet
    ON_FIRST_MH_MAX_HOPS_COUNT = 2,
    
    //! Size in bytes of a XTEA key fragment
    ONE_NET_XTEA_KEY_FRAGMENT_SIZE = 4
};

//! Address related constants
enum
{
    //! Raw Network ID length (in bytes needed to store the value)
    ONE_NET_RAW_NID_LEN = 5,

    //! Raw Device ID length (in bytes needed to store the value)
    ONE_NET_RAW_DID_LEN = 2,

    //! Raw System ID length (in bytes)
    ONE_NET_RAW_SID_LEN = 6,


    //! Encoded Network ID length (in bytes)
    ON_ENCODED_NID_LEN = 6,

    //! Encoded Device ID length (in bytes)
    ON_ENCODED_DID_LEN = 2,

    //! Encoded SID length (in bytes)
    ON_ENCODED_SID_LEN = 8
};

//! Packet related constants
enum
{
    //! The size of the encoded Packet ID field
    ON_ENCODED_PID_SIZE = 1,

    //! The number of bytes required to store the raw hops field
    ON_RAW_HOPS_SIZE = 1,

    //! The size of the encoded hops field (in bytes)
    ON_ENCODED_HOPS_SIZE = 1,

    //! The length of an encoded Invite MASTER Invite new CLIENT
    ON_ENCODED_INVITE_PKT_LEN = 48,

    //! The length of an encoded single data packet
    ON_ENCODED_SINGLE_DATA_LEN = 26,

    #ifdef _BLOCK_MESSAGES_ENABLED
        //! The maximum length of a raw payload field (not including the extra
        //! byte needed to store the 2 bits for the encryption method type).
        ON_MAX_RAW_PLD_LEN = 32,
    #else // ifdef _BLOCK_MESSAGES_ENABLED //
        //! The maximum length of a raw payload field (not including the extra
        //! byte needed to store the 2 bits for the encryption method type).
        ON_MAX_RAW_PLD_LEN = 24,
    #endif // else _BLOCK_MESSAGES_ENABLED is not defined //

    #ifdef _BLOCK_MESSAGES_ENABLED
    //! The length of an encoded block data packet
    ON_ENCODED_BLOCK_DATA_LEN = 58,
    
    // TODO - get rid of this "block/stream" stuff possibly.  We have a few
    // too many constants?
    //! The length of an encoded block/stream data packet
    ON_ENCODED_BLOCK_STREAM_DATA_LEN = 58,
    #endif
    
    #ifdef _STREAM_MESSAGES_ENABLED
    //! The length of an encoded stream data packet
    ON_ENCODED_STREAM_DATA_LEN = 58,
    #endif

    #ifdef _ONE_NET_VERSION_2_X
    //! The length of an ack/nack packet (in bytes)
    ON_ACK_NACK_LEN = 26,
    #else
    //! The length of an ack/nack packet (in bytes)
    ON_ACK_NACK_LEN = 17,
    #endif

    #ifdef _TRIPLE_HANDSHAKE
    //! The length of a transaction ack packet (in bytes)
    ON_TXN_ACK_LEN = 15,
    #endif

    #ifdef _DATA_RATE
    //! The length of an encoded data rate packet
    ON_DATA_RATE_PKT_LEN = 20,
    #endif

    #ifdef _BLOCK_MESSAGES_ENABLED
    //! Maximum length of an encoded packet (in bytes)
    ONE_NET_MAX_ENCODED_PKT_LEN = ON_ENCODED_BLOCK_DATA_LEN,
    #else
    //! Maximum length of an encoded packet (in bytes)
    ONE_NET_MAX_ENCODED_PKT_LEN = ON_ENCODED_INVITE_PKT_LEN,
    #endif
    
    //! The minimum length the size of the data location that stores packets
    //! must be (in bytes).  This is not the length of the actual packet
    //! (which may be shorter than this value).    
    // TODO - Derek_S August 2, 2011 - shouldn't this be ON_TXN_ACK_LEN?
    ON_MIN_ENCODED_PKT_SIZE = ON_ACK_NACK_LEN,

    //! The index into the encoded packet where the destination DID starts.
    ONE_NET_ENCODED_DST_DID_IDX = 4,

    //! The index into the encoded packet where the NID starts.
    ON_ENCODED_NID_IDX = ONE_NET_ENCODED_DST_DID_IDX + ON_ENCODED_DID_LEN,

    //! The index into the encoded packet where the source DID starts.
    ON_ENCODED_SRC_DID_IDX = ON_ENCODED_NID_IDX + ON_ENCODED_NID_LEN,

    //! The index into the encoded packet where the PID starts.
    ONE_NET_ENCODED_PID_IDX = ON_ENCODED_SRC_DID_IDX + ON_ENCODED_DID_LEN,

    //! The index into the encoded packet where the payload starts
    ON_PLD_IDX = ONE_NET_ENCODED_PID_IDX + ON_ENCODED_PID_SIZE
};


// these constants represents how many bytes need to be read in for the
// various groups of packets that are received.
enum
{
    // Number of bytes - Preamble & SOF to receive for invite
    RX_INVITE_LEN = ON_ENCODED_INVITE_PKT_LEN - ONE_NET_ENCODED_DST_DID_IDX,

    // Number of bytes - Preamble & SOF to receive for single, block, and
    // stream data acks, nacks, and keep alives
    RX_DATA_ACK_NACK_LEN = ON_ACK_NACK_LEN - ONE_NET_ENCODED_DST_DID_IDX,

    #ifdef _TRIPLE_HANDSHAKE
    // Number of bytes - Preamble & SOF to receive for single, block, and
    // stream transaction acks.
    RX_TXN_ACK_LEN = ON_TXN_ACK_LEN - ONE_NET_ENCODED_DST_DID_IDX,
	#endif
    
    // Number of bytes - Preamble & SOF to receive for single data packets
    RX_SINGLE_DATA_LEN = ON_ENCODED_SINGLE_DATA_LEN - ONE_NET_ENCODED_DST_DID_IDX,
    
	#ifdef _BLOCK_MESSAGES_ENABLED
    // Numbeer of bytes - Preamble & SOF to receive for block and stream
    // data packets
    RX_BLOCK_STREAM_DATA_LEN = ON_ENCODED_BLOCK_STREAM_DATA_LEN - ONE_NET_ENCODED_DST_DID_IDX,
	#endif
    
    #ifdef _DATA_RATE
    // Number of bytes - Preamble & SOF to receive for data rate packets
    RX_DATA_RATE_TEST_LEN = ON_DATA_RATE_PKT_LEN - ONE_NET_ENCODED_DST_DID_IDX
    #endif
};	



//! Invite related constants
enum
{
    //! The length (in bytes) of the raw invite request packet.  The 25th byte
    //! contains the 2 bits for the method used to encrypt the data with.
    ON_RAW_INVITE_SIZE = 25,

    //! The length (in bytes) of the encoded invite portion of the invite
    //! request packet.  This includes the extra byte needed to store the 2 bits
    //! for the encryption type.  This is also the size of the invite in 6 bit
    //! words
    ON_ENCODED_INVITE_SIZE = 33,

    //! The number of bytes to compute the crc over in the invite message
    ON_INVITE_DATA_LEN = 23,

    //! The version index
    ON_INVITE_VERSION_IDX = 0,

    //! The assigned DID index
    ON_INVITE_ASSIGNED_DID_IDX = 1,

    //! The key index
    ON_INVITE_KEY_IDX = 3,

    //! The keep alive index
    ON_INVITE_KEEP_ALIVE_IDX = 19,

    //! The crc index
    ON_INVITE_CRC_IDX = 23
};

//! Payload & response packet related constants
enum
{
    //! The size of the payload header (crc, txn & response nonce,
    //! message type) in bytes.
    ON_RAW_PLD_HDR_SIZE = 3,

    //! Length of the payload field in a raw single data packet (in bytes needed
    //! to store all the information)
    ON_RAW_SINGLE_PLD_SIZE = 9,

    //! Length of the payload field in an encoded single data packet (in bytes)
    ON_ENCODED_SINGLE_PLD_SIZE = 11,

    //! Length of the actual app/admin data portion of a raw single packet
    //! (in bytes)
    ONE_NET_RAW_SINGLE_DATA_LEN = 5,

    //! Length of the payload field in block and stream packets (in bytes needed
    //! to store all the information)
    ON_RAW_BLOCK_STREAM_PLD_SIZE = 33,

    //! Length of the payload field in block and stream packets (in bytes)
    ON_ENCODED_BLOCK_STREAM_PLD_SIZE = 43,

    //! Length of the actual app/admin data portion of a raw block or stream
    //! packet (in bytes)
    ONE_NET_RAW_BLOCK_STREAM_DATA_LEN = 29,

    //! The maximum number of bytes that can be sent in an entire block
    //! transaction.
    ON_MAX_BLOCK_TRANSFER_LEN = 65535,

    //! The maximum admin payload size (in bytes)
    ON_MAX_ADMIN_PLD_LEN = 4,


    //! Length of the payload field in a ACK/NACK packet with nonces
    ON_RAW_ACK_NACK_PLD_SIZE = 9,

    //! Length of the payload field in an encoded ACK/NACK packet
    // with nonces (in bytes)
    ON_ENCODED_ACK_NACK_PLD_SIZE = 11,
};

//! Payload CRC releated constants
enum
{
    //! The size of the crc in the payload (in bytes)
    ON_PLD_CRC_SIZE = 1,

    //! The initial payload crc
    ON_PLD_INIT_CRC = 0xFF,

    //! The order of the payload crc
    ON_PLD_CRC_ORDER = 8,

    //! The initial crc for the non-volatile parameters
    ON_PARAM_INIT_CRC = 0xFF,

    //! The order of the crc computed over the non-volatile parameters
    ON_PARAM_CRC_ORDER = 8
};

//! Payload and Response Parsing Constants
enum
{
    // TODO - are the 3 constants below needed for version 2.0?
	
    //! Index for the transaction nonce in a response packet
    ON_RESP_TXN_NONCE_IDX = 0,

    //! Index for the high portion of the response nonce in a response packet
    ON_RESP_RESP_NONCE_HIGH_IDX = 0,

    //! Index for the low portion of the response nonce in a response packet
    ON_RESP_RESP_NONCE_LOW_IDX = 1,


    //! Index into the payload where the crc starts
    ON_PLD_CRC_IDX = 0,

    //! Index for the transaction nonce
    ON_PLD_TXN_NONCE_IDX = 1,

    //! Index for the high portion of the response nonce
    ON_PLD_RESP_NONCE_HIGH_IDX = 1,

    //! Index for the low portion of the response nonce
    ON_PLD_RESP_NONCE_LOW_IDX = 2,

    //! Index for the message type
    ON_PLD_MSG_TYPE_IDX = 2,

    //! Index for the data portion
    ON_PLD_DATA_IDX = 3,

    // If any of the shift values change, the masks where these values are used
    // will also need to change
    //! Number of bits to shift the transaction nonce
    ON_TXN_NONCE_SHIFT = 2,

    //! Number of bits to shift the high portion of the response nonce
    ON_RESP_NONCE_HIGH_SHIFT = 4,

    //! Number of bits to shift the low portion of the response nonce
    ON_RESP_NONCE_LOW_SHIFT = 4,

    //! The mask to use for the transaction nonce when building the payload
    //! field of a data packet
    ON_TXN_NONCE_BUILD_MASK = 0xFC,

    //! The mask to use for the transaction nonce when parsing the payload
    //! field of a data packet
    ON_TXN_NONCE_PARSE_MASK = 0x3F,

    //! The mask to use for the high portion of the response nonce when
    //! building the payload field of a data packet
    ON_RESP_NONCE_BUILD_HIGH_MASK = 0x03,

    //! The mask to use for the high portion of the response nonce when
    //! parsing the payload field of a data packet
    ON_RESP_NONCE_PARSE_HIGH_MASK = 0x30,

    //! The mask to use for the low portion of the response nonce when
    //! building the payload field of a data packet
    ON_RESP_NONCE_BUILD_LOW_MASK = 0xF0,

    //! The mask to use for the low portion of the response nonce when
    //! parsing the payload field of a data packet
    ON_RESP_NONCE_PARSE_LOW_MASK = 0x0F,

    //! The mask to use for the message type when building or parsing the
    //! payload field of a data packet
    ON_PLD_MSG_TYPE_MASK = 0x0F
};

/*!
    \brief Admin packet related constants

    The index into the data fields are based on building the data field, not
    an index into the received packet which has the admin message id
    preceding the data field.  For indexing the data fields in received
    packets, ADMIN_DATA_IDX will need to be added to the data field indexes.
*/
enum
{
    //! Index into an admin message for the message id
    ON_ADMIN_MSG_ID_IDX = 0,

    //! Index into an admin message where the data starts.
    ON_ADMIN_DATA_IDX = 1,

    //! Index for version field in Status Response message
    ON_STATUS_VER_IDX = 0,

    //! Index for Max Data Rate field in Status Response message
    ON_STATUS_MAX_DATA_RATE_IDX = 1,

    //! Index for featurs field in Status Response message
    ON_STATUS_FEATURES_IDX = 2,

    //! Index for data rate in a Settings message
    ON_SETTINGS_DATA_RATE_IDX = 0,

    //! Index for MASTER data rate in Settings message
    ON_SETTINGS_MASTER_DATA_RATE_IDX = 1,

    //! Index for flags in Settings message
    ON_SETTINGS_FLAG_IDX = 2,

    //! Index for encoded did of peer device for (un)assignment of peers
    ON_PEER_DID_IDX = 0,

    //! Index for peer unit for (un)assignment of peers.  This is the unit in
    //! the peer device being assigned to a unit in this device
    ON_PEER_PEER_UNIT_IDX = 2,

    //! Index for destination unit for (un)assignment of peers.  This is the
    //! unit in the device that is being assigned a peer
    ON_PEER_SRC_UNIT_IDX = 3,

    #ifdef _DATA_RATE
    //! Index for the peer data rate field in a peer setting packet
    ON_PEER_SETTING_DATA_RATE_IDX = 2,
    #endif
    
    //! Index for the source and desination units for the block/stream request
    //! admin transaction
    ON_BLOCK_STREAM_SRC_DST_IDX = 0,

    //! Index for the data type for the block/stream request admin transaction
    ON_BLOCK_STREAM_DATA_TYPE_IDX = 1,

    //! Index for the block length for the block request admin transaction.
    ON_BLOCK_LEN_IDX = 2,

    #ifdef _DATA_RATE
    //! Index for the data rate for data rate test message
    ON_DATA_RATE_DATA_RATE_IDX = 0,

    //! Index for the did in a data rate test message
    ON_DATA_RATE_DID_IDX = 1,

    //! Index for the Flags field in Initiate Data Rate Test messages
    ON_DATA_RATE_FLAG_IDX = 3,

    //! Index for the data rate result in a data rate test message
    ON_DATA_RATE_RESULT_IDX = 3,
    #endif
};

//! Flags for the features the device supports (for FEATURES field in Status
//! Response admin packets).
//! Bits 0 - 3 Number of peer units supported (0 means peer not supported)
//! Bit 4 - Block capable
//! Bit 5 - Multi-Hop Capable
//! Bit 6 - Multi-Hop Repeater Capable (valid only if Multi-Hop Capable)
//! Bit 7 - If Block is NOT enabled, represents whether Data-Rate functionality
//!         is implemented.  If Block IS enabled, represesnts whether Stream
//!         capable.  If Block is capable, Data Rate will be too.  Stream cannot
//!         be implemented without block

enum
{
    ON_DATA_RATE_CAPABLE = 0x80,    //!< Device will respond to data rate messages
    ON_MH_REPEATER = 0x40,          //!< Multi-Hop Repeater
    ON_MH_CAPABLE = 0x20,           //!< Device is capable of rx/tx MH packets
    ON_BLOCK_CAPABLE = 0x10,        //!< Block capable flag.
    ON_STREAM_CAPABLE = ON_DATA_RATE_CAPABLE | ON_BLOCK_CAPABLE //!< Stream
        //!< Capable mask is 0x90 or 10010000.  Any device with BOTH bits 4 and 7
        //!< enabled is stream capable
};

//! flags for settings admin packet 
enum
{
    //! Flag set when the device is part of the network
    ON_JOINED = 0x80,

    //! Flag to indicate a CLIENT should send a message that it sent to its peer
    //! to the MASTER too.
    ON_SEND_TO_MASTER = 0x40
};

#ifdef _DATA_RATE
//! Flags for Initiate Data Rate admin packets
enum
{
    //! Set if the data rate test should be a Multi-Hop data rate test.
    ON_MH_DATA_RATE_TEST_FLAG = 0x80
};

//! Data Rate constants
enum
{
    //! The size of the data rate field in 6 or 8 bit words
    ON_DATA_RATE_WORD_SIZE = 1,

    //! The index of the data rate field in the payload of a data rate packet
    ON_DATA_RATE_IDX = 15,

    //! The number of bits to shift the raw data rate before encoding or after
    //! decoding
    ON_DATA_RATE_SHIFT = 2,

    //! Index of the start of the test pattern in a data rate packet
    ON_TEST_PATTERN_IDX = 1,

    //! Size of the test pattern in bytes
    ON_TEST_PATTERN_SIZE = 4,

    //! The test pattern
    ON_TEST_PATTERN = 0xE1
};
#endif

enum
{
    //! Unit number that refers to device as a whole
    ONE_NET_DEV_UNIT = 0x0F
};

    
//! @} ONE-NET_const
//                                  CONSTANTS END
//==============================================================================

//==============================================================================
//                                  TYPEDEFS
//! \defgroup ONE-NET_typedefs
//! \ingroup ONE-NET
//! @{

/*!
    \brief Encoded Packet Types
*/
typedef enum
{
#ifdef _ONE_NET_USE_ENCODING
    //! MASTER broadcast inviting a new CLIENT to join the network.
    ONE_NET_ENCODED_MASTER_INVITE_NEW_CLIENT = 0xB4,


    //! Acknowledgment of successful reception of a single data packet.
    ONE_NET_ENCODED_SINGLE_DATA_ACK = 0xBC,

    //! Acknowledgement of successful reception of a single data packet.  Also
    //! tells the sender of the single data packet to listen for a single data
    //! packet from the CLIENT that received the single data packet.
    ONE_NET_ENCODED_SINGLE_DATA_ACK_STAY_AWAKE = 0xB3,

    //! Acknowledges that a single data packet was received, but not 
    //! successfully parsed.
    ONE_NET_ENCODED_SINGLE_DATA_NACK = 0xBA,

    #ifdef _TRIPLE_HANDSHAKE
    //! The sender of the single data is acknowledging that the transaction is
    //! complete (necessary acks received), and that the receiver can stop
    //! listening
    ONE_NET_ENCODED_SINGLE_TXN_ACK = 0xB5,
    #endif

    //! Single Data Packet.
    ONE_NET_ENCODED_SINGLE_DATA = 0xB9,

    //! Repeat of a single data packet
    ONE_NET_ENCODED_REPEAT_SINGLE_DATA = 0xB6,

    #ifdef _BLOCK_MESSAGES_ENABLED
    //! Block Data Packet
    ONE_NET_ENCODED_BLOCK_DATA = 0xB2,

    //! Repeat of a block data packet
    ONE_NET_ENCODED_REPEAT_BLOCK_DATA = 0xC4,

    //! Acknowledgment of successful reception of a single data packet.
    ONE_NET_ENCODED_BLOCK_DATA_ACK = 0xCC,

    //! Acknowledges that a block data packet was received, but was not
    //! successfully parsed
    ONE_NET_ENCODED_BLOCK_DATA_NACK = 0xC3,

    //! The sender of the block data is acknowledging that the transaction is
    //! complete (necessary acks received), and that the receiver can stop
    //! listening
    ONE_NET_ENCODED_BLOCK_TXN_ACK = 0xCA,
    #endif

    #ifdef _STREAM_MESSAGES_ENABLED
    //! Stream Data Packet
    ONE_NET_ENCODED_STREAM_DATA = 0xC5,

    //! Sent by the receiver of a stream data packet to alert the sender that
    //! it is still receiving the stream.
    ONE_NET_ENCODED_STREAM_KEEP_ALIVE = 0xC9,
	#endif

    #ifdef _DATA_RATE
    //! Sent during a data rate test.
    ONE_NET_ENCODED_DATA_RATE_TEST = 0xC6,
    #endif

    //! Acknowledges that a single data packet was received, but an
    //! error was encountered. The NACK reason field on this NACK specifies
    //! the error condition that resulted in the NACK.
    ONE_NET_ENCODED_SINGLE_DATA_NACK_RSN = 0x64,

    #ifdef _BLOCK_MESSAGES_ENABLED
    //! Acknowledges that a block data packet was received, but an
    //! error was encountered. The NACK reason field on this NACK specifies
    //! the error condition that resulted in the NACK.
    ONE_NET_ENCODED_BLOCK_DATA_NACK_RSN = 0x6C,
    #endif
	
#else
    //! MASTER broadcast inviting a new CLIENT to join the network.
    ONE_NET_ENCODED_MASTER_INVITE_NEW_CLIENT = 0x00,


    //! Acknowledgment of successful reception of a single data packet.
    ONE_NET_ENCODED_SINGLE_DATA_ACK = 0x01,

    //! Acknowledgement of successful reception of a single data packet.  Also
    //! tells the sender of the single data packet to listen for a single data
    //! packet from the CLIENT that received the single data packet.
    ONE_NET_ENCODED_SINGLE_DATA_ACK_STAY_AWAKE = 0x02,

    //! Acknowledges that a single data packet was received, but not 
    //! successfully parsed.
    ONE_NET_ENCODED_SINGLE_DATA_NACK = 0x03,

    #ifdef _TRIPLE_HANDSHAKE
    //! The sender of the single data is acknowledging that the transaction is
    //! complete (necessary acks received), and that the receiver can stop
    //! listening
    ONE_NET_ENCODED_SINGLE_TXN_ACK = 0x04,
    #endif

    //! Single Data Packet.
    ONE_NET_ENCODED_SINGLE_DATA = 0x05,

    //! Repeat of a single data packet
    ONE_NET_ENCODED_REPEAT_SINGLE_DATA = 0x06,

    //! Block Data Packet
    ONE_NET_ENCODED_BLOCK_DATA = 0x07,

    //! Repeat of a block data packet
    ONE_NET_ENCODED_REPEAT_BLOCK_DATA = 0x08,

    //! Acknowledgment of successful reception of a single data packet.
    ONE_NET_ENCODED_BLOCK_DATA_ACK = 0x09,

    //! Acknowledges that a block data packet was received, but was not
    //! successfully parsed
    ONE_NET_ENCODED_BLOCK_DATA_NACK = 0x0A,

    //! The sender of the block data is acknowledging that the transaction is
    //! complete (necessary acks received), and that the receiver can stop
    //! listening
    ONE_NET_ENCODED_BLOCK_TXN_ACK = 0x0B,

    #ifdef _STREAM_MESSAGES_ENABLED
    //! Stream Data Packet
    ONE_NET_ENCODED_STREAM_DATA = 0x0C,

    //! Sent by the receiver of a stream data packet to alert the sender that
    //! it is still receiving the stream.
    ONE_NET_ENCODED_STREAM_KEEP_ALIVE = 0x0D,
	#endif

    #ifdef _DATA_RATE
    //! Sent during a data rate test.
    ONE_NET_ENCODED_DATA_RATE_TEST = 0x0E,
    #endif

    //! Acknowledges that a single data packet was received, but an
    //! error was encountered. The NACK reason field on this NACK specifies
    //! the error condition that resulted in the NACK.
    ONE_NET_ENCODED_SINGLE_DATA_NACK_RSN = 0x30,

    //! Acknowledges that a block data packet was received, but an
    //! error was encountered. The NACK reason field on this NACK specifies
    //! the error condition that resulted in the NACK.
    ONE_NET_ENCODED_BLOCK_DATA_NACK_RSN = 0x31,
#endif
} on_pid_t;


/*!
    \brief Data Packet Message Types
*/
typedef enum
{
    ON_APP_MSG,                     //!< Application message type
    ON_ADMIN_MSG,                   //!< Admin message type
	#ifdef _STREAM_MESSAGES_ENABLED
    ON_EXTENDED_ADMIN_MSG,          //!< Extended admin message type (for block)
	#endif
    
    ON_INVALID_MSG_TYPE             //!< Indicates the message type is not valid
} on_msg_type_t;


/*!
    \brief Raw Admin Message Type
*/
typedef enum
{
    //! Queries the status of the device
    ON_STATUS_QUERY = 0x00,

    //! Response to a Status Query.  This is also the message sent when a device
    //! hears a MASTER Invite New CLIENT when it is joining the network to let
    //! the MASTER know it has joined the network, and it's capabilities.
    ON_STATUS_RESP = 0x01,

    //! Queries a device for it's communication settings.
    ON_SETTINGS_QUERY = 0x02,

    //! Response to a Settings Query.  This is also the response to a Change
    //! Settings so the MASTER knows that the changes it proposed took affect.
    ON_SETTINGS_RESP = 0x03,

    //! Sent to change a device's settings.  The devices settings should not
    //! be considered changed until a SETTINGS_RESP is received.
    ON_CHANGE_SETTINGS = 0x04,

    //! Query for the devices fragment delay.
    ON_FRAGMENT_DELAY_QUERY = 0x05,

    //! Response to a fragment delay query or change fragment delay
    ON_FRAGMENT_DELAY_RESP = 0x06,

    //! Sent to change a devices low priority fragment delay
    ON_CHANGE_LOW_FRAGMENT_DELAY = 0x07,

    //! Query for the Keep Alive Timeout.  This is the interval at which a
    //! CLIENT must attempt to check in with the MASTER.  Any communication
    //! with the MASTER resets this timer.
    ON_KEEP_ALIVE_QUERY = 0x08,

    //! Response to the Keep Alive Query.  This is how often a client attempts
    //! to check in with the MASTER.  Any communication with the MASTER resets
    //! this timer.
    ON_KEEP_ALIVE_RESP = 0x09,

    //! Sent to change the keep alive interval
    ON_CHANGE_KEEP_ALIVE = 0x0A,

    //! Sent by the MASTER to update a CLIENT's key.  The key is updated by
    //! removing the upper 32 bits, and appending the 32 bits in this message
    //! to the remaining 96 bits of the key.
    ON_NEW_KEY_FRAGMENT = 0x0B,

#ifdef _PEER
    //! Sent by the MASTER to assign a peer to the receiving CLIENT.  The CLIENT
    //! can then send directly to the peer.
    ON_ASSIGN_PEER = 0x0C,

    //! Sent by the MASTER to un-assign a peer from the receiving CLIENT.  The
    //! CLIENT must not send directly to that peer anymore.
    ON_UNASSIGN_PEER = 0x0D,
#endif

    //! Sent by a device that wishes to receive a low priority block transaction
    //! from the device that receives this message.
    ON_SEND_BLOCK_LOW = 0x0E,

    //! Sent by a device that wishes to send a low priority block transaction to
    //! the device that receives this message.
    ON_RECV_BLOCK_LOW = 0x0F,

    //! Sent by a device that wishes to receive a low priority stream
    //! transaction from the device that receives this message
    ON_SEND_STREAM_LOW = 0x10,

    //! Sent by a device that wishes to send a low priority stream transaction
    //! to the device that receives this message.
    ON_RECV_STREAM_LOW = 0x11,

    //! Sent by a device to end a stream transaction
    ON_END_STREAM = 0x12,

    #ifdef _DATA_RATE
    //! The MASTER is initiating a data rate test with a CLIENT.
    ON_INIT_DATA_RATE_TEST = 0x13,
    #endif

    //! The test result of a data rate test.
    ON_DATA_RATE_RESULT = 0x14,

    //! Not used
    ON_ADMIN_UNUSED0,

    //! Not Used
    ON_ADMIN_UNUSED1,

    //! Not Used
    ON_ADMIN_UNUSED2,

    //! Not Used
    ON_ADMIN_UNUSED3,

    //! Not Used
    ON_ADMIN_UNUSED4,

    #ifdef _DATA_RATE
    //! Sent to update the data rate to use when sending to a specific peer.
    ON_CHANGE_PEER_DATA_RATE = 0x1A,
    #endif

    //! Sent to change a devices high priority fragment delay
    ON_CHANGE_HIGH_FRAGMENT_DELAY = 0x1B,

    //! Sent by a device that wishes to receive a high priority block
    //! transaction from the device that receives this message.
    ON_SEND_BLOCK_HIGH = 0x1C,

    //! Sent by a device that wishes to send a high priority block
    //! transaction to the device that receives this message.
    ON_RECV_BLOCK_HIGH = 0x1D,

    //! Sent by a device that wishes to receive a high priority stream
    //! transaction from the device that receives this message
    ON_SEND_STREAM_HIGH = 0x1E,

    //! Sent by a device that wishes to send a high priority stream
    //! transaction to the device that receives this message.
    ON_RECV_STREAM_HIGH = 0x1F,
    
    //! Queries the MASTER for the stream key
    ON_STREAM_KEY_QUERY = 0x21,

    //! Sent by the MASTER when it is removing the receiver from the network
    ON_RM_DEV = 0x22
} on_admin_msg_t;


// temporarily keeping on_nack_rsn_t in the Version 1.X strain.  This may or may not be implemented.
/*!
    Nack Reasons
*/
typedef enum
{
    ON_NACK_RSN_NO_ERROR,            //! Not an error.  Should not be part of a packet, but defined so that we can use it as "success" when coding
    ON_NACK_RSN_NONCE_ERR,           //! received nonce does not match expected one
	ON_NACK_RSN_DEVICE_FUNCTION_ERR, //! specified Device lacks the functionality to properly process the received packet
	ON_NACK_RSN_UNIT_FUNCTION_ERR,   //! specified Unit lacks the functionality to properly process the received packet (although the Device itself does)
	ON_NACK_RSN_INVALID_UNIT_ERR,    //! nonexistent Unit specified
	ON_NACK_RSN_MISMATCH_UNIT_ERR,   //! Unit pair specified in Block Data Segment does not match that in Request to Receive Block
	ON_NACK_RSN_RSRC_UNAVAIL_ERR,    //! resource(s) necessary to complete the transaction not currently available
	ON_NACK_RSN_INVALID_LENGTH_ERR,  //! specified Device/Unit cannot handle a transaction with the specified length
	ON_NACK_RSN_BAD_DATA_ERR,        //! improperly formatted data
	ON_NACK_RSN_TRANSACTION_ERR,     //! invalid transaction specified (such as a Block Data packet in the absence of a previous Block Request)
	ON_NACK_RSN_INTERNAL_ERR,        //! something unanticipated occurred - Under normal circumstances, this should never be received (as it indicates an implementation fault in the sender); Devices are required to process it, however.	
    ON_NACK_RSN_MAX_FAILED_ATTEMPTS_REACHED, //! Attempted and failed too many times.
	ON_NACK_RSN_BUSY, //! Application level code specifying that the device cannot service the request at this time.  No specification of when to try again.  Considered "fatal" by ONE-NET.
	ON_NACK_RSN_BUSY_TRY_AGAIN, //! Application level code specifying that the device cannot service the request at this time, but will likely be able to do so very soon.  Considered "non-fatal" by ONE-NET.
	ON_NACK_RSN_BUSY_TRY_AGAIN_TIME, //! Application level code specifying that the device cannot service the request at this time, but will likely be able to do so very soon.  Considered "non-fatal" by ONE-NET, but application code may override.
    ON_NACK_RSN_BAD_POSITION_ERROR,  //! Position/Offset is invalid and/or does not match what is expected by the device.
    ON_NACK_RSN_BAD_SIZE_ERROR,      //! Length/Size is invalid and/or does not mach what is expected by the device.  Different from ON_NACK_RSN_INVALID_LENGTH_ERRON_NACK_RSN_INVALID_LENGTH_ERR, which means that the device cannot HANDLE something this size.
    ON_NACK_RSN_BAD_ADDRESS_ERR,     //! DID or NID is either not decodable or is incorrect.
    ON_NACK_RSN_UNSET = 0x1D,        //! Nack Reason is not set yet.
    ON_NACK_RSN_FATAL_ERR = 0x1E,           //! Some unspecified fatal error occurred.  Don't try to resend.
    ON_NACK_RSN_GENERAL_ERR = 0x1F,  //! If no specific reason is known
	ON_NACK_RSN_MIN_USR_GENERAL = 0x20, //! NACK Reasons 0x20 through 0x2F are user-defined NACKs.  They are not pre-defined as fatal or non-fatal.
	ON_NACK_RSN_MAX_USR_GENERAL = 0x2F, //! NACK Reasons 0x20 through 0x2F are user-defined NACKs.  They are not pre-defined as fatal or non-fatal.
	ON_NACK_RSN_MIN_USR_NON_FATAL = 0x30, //! NACK Reasons 0x30 through 0x37 are user-defined non-fatal NACKs
	ON_NACK_RSN_MAX_USR_NON_FATAL = 0x37, //! NACK Reasons 0x30 through 0x37 are user-defined non-fatal NACKs
	ON_NACK_RSN_MIN_USR_FATAL = 0x38, //! NACK Reasons 0x38 through 0x3F are user-defined fatal NACKs
	ON_NACK_RSN_MAX_USR_FATAL = 0x3F, //! NACK Reasons 0x38 through 0x3F are user-defined fatal NACKs
	ON_NACK_RSN_MAX_NACK_RSN_VALUE = ON_NACK_RSN_MAX_USR_FATAL
} on_nack_rsn_t;



// note : below are some named constants.  Since this is C, not C++, enumerated types are simply aliases for
// integers, so we'll use on_ack_handle_t, on_nack_handle_t, and on_ack_nack_handle_t interchangably.
// ON_ACK_STATUS only makes sense for an ACK, so don't use it for an on_nack_handle_t.  The
// compiler could not care less, but consistency makes it easier for us humans to read.

// Note that "handle" does not refer to the computer science term "handle".  Rather, it refers to
// how ONE-NET should interpret and "handle" packet information (either as random padding (ON_ACK/ON_NACK),
// a generic data array (ON_ACK_DATA, ON_NACK_DATA), a 32-but integer value (ON_ACK_32_BIT_INT/ON_NACK_32_BIT),
// or a status message(ON_ACK_STATUS), possibly in response to a query.
/*!
    Specifies what an ACK means and whether there is any data accompanying it
*/
typedef enum
{
	ON_ACK,                //! Normal ACK with no accompanying data
	ON_ACK_DATA,           //! The ACK is accompanied by 5 bytes of data.
	ON_ACK_VALUE,          //! The ACK is accompanied by 8 bit and 32 bit unsigned integers.
	ON_ACK_TIME_MS,        //! The ACK is accompanied by a 32 bit unsigned integer representing time in milliseconds
	ON_ACK_STATUS          //! The ACK is accompanied by the device's current status.  This will usually be in response to a "fast query" request
} on_ack_handle_t;


/*!
    Specifies what a NACK means and whether there is any data accompanying it.  Same as ACK values.
	Just defined here so you can use whichever you like.  These MUST correspond to the on_ack_handle_t values.
*/
typedef enum
{
	ON_NACK,            //! Normal NACK with no accompanying data
	ON_NACK_DATA,       //! The NACK is accompanied by 5 bytes of data.
	ON_NACK_VALUE,      //! The NACK is accompanied by a 32 bit unsigned integer.
	ON_NACK_TIME_MS,    //! The NACK is accompanied by a 32 bit unsigned integer representing time in milliseconds
} on_nack_handle_t;


typedef on_ack_handle_t on_ack_nack_handle_t; // it's all ints anyway


typedef struct
{
	UInt8 uint8;
	UInt32 uint32;
} ack_value_t;


/*!
    The payload of an ACK or a NACK.
*/
typedef union
{
    UInt8 status_resp[5]; // only valid for ACKs.  Generally, but not
	                      // exclusively intended for "fast query"/"poll"
						  // responses.
	UInt8 ack_payload[5];
	ack_value_t ack_value;
    tick_t ack_time_ms;
	UInt8 nack_payload[4]; // NACK cannot hold 5 bytes since it has the reason field
	UInt32 nack_value;
    tick_t nack_time_ms;
} ack_nack_payload_t;


#ifdef _STREAM_MESSAGES_ENABLED
/*!
    Extended admin types
*/
typedef enum
{
    //! Changes the stream key
    ON_CHANGE_STREAM_KEY
} on_extended_admin_msg_t;
#endif


//! Data rate type
typedef enum
{
    ONE_NET_DATA_RATE_38_4,         //!< 38400 bps
    ONE_NET_DATA_RATE_76_8,         //!< 76800 bps
    ONE_NET_DATA_RATE_115_2,        //!< 115200 bps
    ONE_NET_DATA_RATE_153_6,        //!< 153600 bps
    ONE_NET_DATA_RATE_192_0,        //!< 192000 bps
    ONE_NET_DATA_RATE_230_4,        //!< 230400 bps

    //! 1 more than the max data rate.  Data rates must be added before this
    //! value
    ONE_NET_DATA_RATE_LIMIT
} on_data_rate_t;
// TODO: should this now be called one_net_data_rate_t since data rates are now in the public interface
//       for the one-net functions that were added to support Blue Spot


//! Data type being sent/received
typedef enum
{
    ON_NO_TXN = 0,                      //!< No data being sent or received
    ON_INVITE = 1,                      //!< CLIENT Invitation packet.
    #ifdef _DATA_RATE
    ON_DATA_RATE_TXN = 2,               //!< Carrying out a data rate test
    #endif
    ON_SINGLE = 3,                      //!< Sending a single data packet
	#ifdef _STREAM_MESSAGES_ENABLED
    ON_STREAM = 4,                      //!< Sending a stream data packet
	#endif
    #ifdef _BLOCK_MESSAGES_ENABLED
    ON_BLOCK = 5                        //!< Sending a block data packet
    #endif
} on_data_t;


/*!
    \brief Priority Levels

    \Note Changing these may cause the implementation of the Fragment delays
      admin messages to be changed.
*/
typedef enum
{
    ONE_NET_NO_PRIORITY,            //!< No current transaction
    ONE_NET_LOW_PRIORITY,           //!< Low priority transaction
    ONE_NET_HIGH_PRIORITY,          //!< High priority transaction
    ONE_NET_SEND_SINGLE_PRIORITY = ONE_NET_HIGH_PRIORITY

} on_priority_t;


/*!
    \brief States.

    Changing the states will likely require changing the code were they are
    used. All the WRITE_WAIT states need to be 1 more than the send states.
    All the states after the WRITE_WAIT states need to be 1 more than the
    WRITE_WAIT states.
*/
typedef enum
{
    //! Listen for single, block, or stream (or repeat) data packets
    ON_LISTEN_FOR_DATA,


    //! Sends a packet that does not expect a response back
    ON_SEND_PKT = 10,

    //! Waits for the write to end
    ON_SEND_PKT_WRITE_WAIT,


    //! Sends a Single Data Packet
    ON_SEND_SINGLE_DATA_PKT = 20,

    //! Waits for the write to end
    ON_SEND_SINGLE_DATA_WRITE_WAIT,

    //! Waits for the response to a single data packet
    ON_WAIT_FOR_SINGLE_DATA_RESP,


    //! State to send the single data response
    ON_SEND_SINGLE_DATA_RESP = 30,

    //! Waits for the write to end
    ON_SEND_SINGLE_DATA_RESP_WRITE_WAIT,

    #ifdef _TRIPLE_HANDSHAKE
    //! Listens for the end of a single transaction (txn ack, or next single
    //! data packet)
    ON_WAIT_FOR_SINGLE_DATA_END,
	#endif


    #ifdef _BLOCK_MESSAGES_ENABLED
    //! Sends a block data packet
    ON_SEND_BLOCK_DATA_PKT = 40,

    //! Waits for the write to end
    ON_SEND_BLOCK_DATA_WRITE_WAIT,

    //! Waits for the response to a block data packet
    ON_WAIT_FOR_BLOCK_DATA_RESP,


    //! State to send the block data response
    ON_SEND_BLOCK_DATA_RESP = 50,

    //! Waits for the write to end
    ON_SEND_BLOCK_DATA_RESP_WRITE_WAIT,

    //! Listens for the end of the block transaction
    ON_WAIT_FOR_BLOCK_DATA_END,
	#endif

    #ifdef _STREAM_MESSAGES_ENABLED
    //! Sends a stream data packet
    ON_SEND_STREAM_DATA_PKT = 60,

    //! Waits for the write to end
    ON_SEND_STREAM_DATA_WRITE_WAIT,

    //! Waits for the response to a stream data packet
    ON_WAIT_FOR_STREAM_DATA_RESP,


    //! State to send the stream data response
    ON_SEND_STREAM_DATA_RESP = 70,

    //! Waits for the write to end
    ON_SEND_STREAM_DATA_RESP_WRITE_WAIT,
	#endif

    #ifdef _DATA_RATE
    //! State to set up to send a data rate test
    ON_INIT_SEND_DATA_RATE = 80,

    //! Send the data rate packet
    ON_SEND_DATA_RATE,

    //! Waits for the write to end
    ON_SEND_DATA_RATE_WRITE_WAIT,

    //! Receive the response data rate packet
    ON_RX_DATA_RATE_RESP,


    //! State to set up to receive a data rate test
    ON_INIT_RX_DATA_RATE = 90,

    //! Receives the data rate packet
    ON_RX_DATA_RATE,

    //! Sends the data rate response
    ON_SEND_DATA_RATE_RESP,

    //! Waits for the write to end
    ON_SEND_DATA_RATE_RESP_WRITE_WAIT,
    #endif

#ifdef _IDLE	
	//! do nothing
	ON_IDLE,
#endif

    //! State when the device has not yet joined the netwrok.  If the device is
    //! a client, it looks for the invite from the MASTER.  If the device is a
    //! MASTER, it looks for a clear channel to establish its network on.
    ON_JOIN_NETWORK = 500,


    //! The default state when the device starts up (to ensure the proper
    //! initialization routines are called)
    ON_INIT_STATE = 1000
} on_state_t;

/*!
    \brief Encryption method used to encrypt single and block transactions

    The encryption method for a packets payload is only 2 bits.  These
    enumerations represent the 2 bit field indicating what method of
    encryption was used (already shifted to their position in the payload).
*/
typedef enum
{
    //! No encryption used. DEBUG ONLY
    ONE_NET_SINGLE_BLOCK_ENCRYPT_NONE = 0x00,

    //! 32 round XTEA
    ONE_NET_SINGLE_BLOCK_ENCRYPT_XTEA32 = 0x40,

    //! TBD
    ONE_NET_SINGLE_BLOCK_ENCRYPT_TBD0 = 0x80,

    //! TBD
    ONE_NET_SINGLE_BLOCK_ENCRYPT_TBD1 = 0xC0
} one_net_single_blk_encryption_t;


/*!
    \brief Encryption method used to encrypt stream transactions

    The encryption method for a packets payload is only 2 bits.  These
    enumerations represent the 2 bit field indicating what method of
    encryption was used (already shifted to their position in the payload).
*/
typedef enum
{
    //! No encryption used. DEBUG ONLY
    ONE_NET_STREAM_ENCRYPT_NONE = 0x00,

    //! 32 round XTEA
    ONE_NET_STREAM_ENCRYPT_XTEA8 = 0x40,

    //! TBD
    ONE_NET_STREAM_ENCRYPT_TBD0 = 0x80,

    //! TBD
    ONE_NET_STREAM_ENCRYPT_TBD1 = 0xC0
} one_net_stream_encryption_t;


//! type of a raw Network ID
typedef UInt8 one_net_raw_nid_t[ONE_NET_RAW_NID_LEN];

//! type of a raw Device ID
typedef UInt8 one_net_raw_did_t[ONE_NET_RAW_DID_LEN];

//! type of a raw System ID
typedef UInt8 one_net_raw_sid_t[ONE_NET_RAW_SID_LEN];

//! type of an encoded Network ID
typedef UInt8 on_encoded_nid_t[ON_ENCODED_NID_LEN];

//! type of an encoded Device ID
typedef UInt8 on_encoded_did_t[ON_ENCODED_DID_LEN];

//! type of an encoded System ID
typedef UInt8 on_encoded_sid_t[ON_ENCODED_SID_LEN];

//! type of the XTEA key fragment
typedef UInt8 one_net_xtea_key_fragment_t[ONE_NET_XTEA_KEY_FRAGMENT_SIZE];



typedef struct
{
    UInt8 payload[ONE_NET_RAW_SINGLE_DATA_LEN];
	UInt8 data_len;
    UInt8 priority;
	BOOL send_to_peer_list;
	one_net_raw_did_t raw_dst;
	UInt8 src_unit;
    #if _SINGLE_QUEUE_LEVEL > MIN_SINGLE_QUEUE_LEVEL
	tick_t send_time;
    #endif
    #if _SINGLE_QUEUE_LEVEL > MED_SINGLE_QUEUE_LEVEL   
	tick_t expire_time;
    #endif
} on_single_data_queue_t;




/*!
    \brief Contains the base set of parameters needed to run.

    These are the parameters needed by devices if they are already part of the
    network.
*/
typedef struct
{
    //! crc over the parameters
    UInt8 crc;

    //! Version of the on_base_param_t, on_master_param_t, client_t,
    //! on_master_t, and on_peer_t structures
    UInt16 version;
    
    UInt8 features; // I see these in on_client_t for the master, but I think
                    // they'd be useful here too.

    //! The encoded address it had been assigned
    on_encoded_sid_t sid;

    //! The channel the network is on
    UInt8 channel;

    //! Data rate the device receives at
    UInt8 data_rate;

    //! The current xtea key being used.
    one_net_xtea_key_t current_key;

    //! Method to encrypt single or block data
    UInt8 single_block_encrypt;

    #ifdef _STREAM_MESSAGES_ENABLED
    //! Key to use for stream data transfers
    one_net_xtea_key_t stream_key;

    //! Method used to encrypt stream data
    UInt8 stream_encrypt;
	#endif
		
    #ifdef _BLOCK_MESSAGES_ENABLED
        //! Low priority fragment delay
        tick_t fragment_delay_low;

        //! High priority fragment delay
        tick_t fragment_delay_high;
    #endif
} on_base_param_t;


enum
{	
    //! The features this client supports
    #if defined(_STREAM_MESSAGES_ENABLED)
        ON_BLOCK_STREAM_DATA_RATE_FEATURES = ON_STREAM_CAPABLE,
    #elif defined(_BLOCK_MESSAGES_ENABLED)
        ON_BLOCK_STREAM_DATA_RATE_FEATURES = ON_BLOCK_CAPABLE,
    #elif defined(_DATA_RATE)
        ON_BLOCK_STREAM_DATA_RATE_FEATURES = ON_DATA_RATE_CAPABLE,
    #else
        ON_BLOCK_STREAM_DATA_RATE_FEATURES = 0,
    #endif
    
    #if defined(_ONE_NET_MH_CLIENT_REPEATER)
        ON_MULTI_FEATURES = ON_MH_REPEATER | ON_MH_CAPABLE,
    #elif defined(_ONE_NET_MULTI_HOP)
        ON_MULTI_FEATURES = ON_MH_CAPABLE,
    #else
        ON_MULTI_FEATURES = 0,
    #endif
    

    ON_PEER_FEATURES = 0, /* this will get overridden at initialization for
                             peer enabled devices. */
   
    ON_FEATURES = ON_BLOCK_STREAM_DATA_RATE_FEATURES | ON_MULTI_FEATURES |
                  ON_PEER_FEATURES
};


/*!
    \brief Info for receiving from a device.

    This structure holds the information needed to receive from a device.
*/
typedef struct
{
    on_encoded_did_t did;           //!< Encoded Device ID of the sender

    UInt8 expected_nonce;           //!< The nonce expected.
    UInt8 last_nonce;               //!< The last nonce received.

    UInt8 send_nonce;               //!< nonce to use in case the device sends
                                    //!< a response txn to the sender.
} on_sending_device_t;

//! Transaction structure
typedef struct
{
    //! The priority of the transaction
    UInt8 priority;

    //! How many times this txn has been tried
    UInt8 retry;

    //! The txn nonce we expect from the recipient
    UInt8 expected_nonce;
    
    //! The type of message.  See msg_type_t for values
    UInt8 msg_type;

    #if defined(_BLOCK_MESSAGES_ENABLED) || defined(_ONE_NET_MASTER)
    //! TRUE if sending this transaction, FALSE if receiving
    BOOL send;
	#endif

    #if defined(_BLOCK_MESSAGES_ENABLED) || defined(_ONE_NET_MASTER)
    //! The timer that contains the time the next block/stream transaction
    //! is supposed to occur if this is a block or stream transaction.
    UInt8 next_txn_timer;
	#endif

    #if defined(_BLOCK_MESSAGES_ENABLED)
    //! The number of bytes remaining to be transferred in a block txn, or
    //! the continue flag for the stream transaction (1 - continue with
    //! transaction, 0 - end transaction).
    UInt16 remaining;
    #endif

    //! The length of the data the packet contains (in bytes).  This will not
    //! contain the hops field, so if a multihop packet is being sent, the
    //! hop field size will need to be added to this value.  This value can
    //! also be used to find the hops field in the packet since the hops field
    //! is at a different index for each packet type
    UInt8 data_len;

    //! The size of the location pkt points to (in bytes)
    UInt8 pkt_size;

    //! The packet to be sent
    UInt8 * pkt;

	//! Any sort of time variable.  Can mean a variety of things.
	//! Usually it refers to when to send a packet
	tick_t time;
} on_txn_t;


//! Packet Handling Function for single or block transactions
typedef one_net_status_t (*on_pkt_hdlr_t)(const UInt8 PID,
  const on_encoded_did_t * const SRC_DID, UInt8 * const pld,
  on_txn_t ** txn);

typedef one_net_status_t (*on_ack_nack_hdlr_t)(on_txn_t* const txn,
    const one_net_raw_did_t* const src_did, on_nack_rsn_t* const nack_reason,
    on_ack_nack_handle_t* const ack_nack_handle,
    ack_nack_payload_t* const ack_nack_payload);

typedef BOOL (*on_status_msg_hdlr_t)(const UInt8* const, const ona_msg_class_t msg_class,
       const ona_msg_type_t msg_type, const UInt8 src_unit,
       const UInt8 dst_unit, const UInt16 msg_data,
       const one_net_raw_did_t* const src_addr, on_nack_rsn_t* const nack_reason,
       on_ack_nack_handle_t* const ack_nack_handle,
       ack_nack_payload_t* const ack_nack_payload);

//! Transaction handler
typedef one_net_status_t (*on_txn_hdlr_t)(on_txn_t ** txn,
  const UInt8 NEXT_NONCE, const one_net_status_t STATUS);

#ifdef _DATA_RATE
//! Data rate results handler
typedef void (*on_data_rate_result_hdlr_t)(const UInt8 RATE,
  const on_encoded_did_t * const DID, const UInt8 RESULT);
#endif

//! The set of needed packet handlers
typedef struct
{
    //! Single Data Packet Handler
    on_pkt_hdlr_t single_data_hdlr;
	
	//! Single Data ACK/NACK Handler
	on_ack_nack_hdlr_t single_ack_nack_hdlr;

	on_status_msg_hdlr_t status_msg_hdlr;

    //! Single transaction handler
    on_txn_hdlr_t single_txn_hdlr;

    #ifdef _BLOCK_MESSAGES_ENABLED
        //! block data packet handler
        on_pkt_hdlr_t block_data_hdlr;

        //! block transaction handler
        on_txn_hdlr_t block_txn_hdlr;
	#endif
	#ifdef _STREAM_MESSAGES_ENABLED
        //! stream data packet handler
        on_pkt_hdlr_t stream_data_hdlr;

        //! stream transaction handler
        on_txn_hdlr_t stream_txn_hdlr;
    #endif

    #ifdef _DATA_RATE
    //! Data Rate Test results handler
    on_data_rate_result_hdlr_t data_rate_hdlr;
    #endif
} on_pkt_hdlr_set_t;

#ifdef _ENHANCED_INVITE
//! Reason why an invitation has been cancelled.
//! TO DO : We may want to make this part of the application code since
//! different applications may have specific codes that shouldn't be part
//! be part of the official ONE-NET package.
typedef enum
{
    CANCEL_INVITE_TIMEOUT, /* look for invitation time has expired */
    CANCEL_INVITE_CANCELLED_BY_USER, /* look for invitation time has expired */
    CANCEL_INVITE_CANCELLED_INTERNAL_ERROR, /* Some error occurred somewhere */
    CANCEL_INVITE_OTHER_REASON /* If none of the reasons above fit. */	
} cancel_invite_reason_t;
#endif


#ifdef _BLOCK_MESSAGES_ENABLED
enum
{
    //! Indicates there is no block data transaction
    NO_BLOCK_TXN = 0xFFFF
};
#endif


//! @} ONE-NET_typedefs
//                                  TYPEDEFS END
//==============================================================================

//==============================================================================
//                              PUBLIC VARIABLES
//! \defgroup ONE-NET_pub_var
//! \ingroup ONE-NET
//! @{



#ifdef _BLOCK_MESSAGES_ENABLED
//! The number of bytes in the entire block transaction.  This value should be
//! set to 0 if there is no pending block transaction.
extern UInt16 block_data_len;

//! The byte number of the start of the payload for the next block data transfer
extern UInt16 block_data_pos;

//! Buffer to store the block data
extern UInt8* block_data;

//! did of device that the block transaction is being carried out with
extern one_net_raw_did_t block_did;

//! TRUE if sending the block transaction, false if receiving
extern BOOL send_block;

//! The type of data being transfered in the block transaction
extern UInt8 block_data_type;

//! The unit sending the block transaction
extern UInt8 block_src_unit;

//! The unit receiving the block transaction
extern UInt8 block_dst_unit;

//! If true, all of the block payload has been successfully transferred
extern BOOL block_byte_transfer_complete;

//! If true, all of the block payload has been successfully transferred
extern BOOL block_txn_ack_rcvd;
#endif

//! The encoded broadcast did.
extern const on_encoded_did_t ON_ENCODED_BROADCAST_DID;

//! The raw broadcast did.
extern const one_net_raw_did_t ON_RAW_BROADCAST_DID;

//! True if device is a master, false otherwise.
extern BOOL deviceIsMaster;


//! @} ONE-NET_pub_var
//                              PUBLIC VARIABLES END
//==============================================================================

//==============================================================================
//                      PUBLIC FUNCTION DECLARATIONS
//! \defgroup ONE-NET_pub_func
//! \ingroup ONE-NET
//! @{


void single_ack_queued(const one_net_raw_did_t* const src_did,
    const UInt8* const raw_pld);
BOOL single_data_is_repeat(const one_net_raw_did_t* const src_did,
    const UInt8* const raw_pld);

void one_net_init(const on_pkt_hdlr_set_t * const PKT_HDLR);

#ifdef _IDLE
    BOOL set_on_state(UInt8 new_on_state);
	void set_allow_set_state(BOOL allow);
#endif

#if _ACK_NACK_LEVEL >= 50
BOOL nack_reason_is_fatal(const on_nack_rsn_t nack_reason);
#endif
#if _SINGLE_QUEUE_LEVEL > NO_SINGLE_QUEUE_LEVEL  
BOOL adjust_single_data_queue(tick_t* const queue_sleep_time);
one_net_status_t place_in_single_queue(const UInt8* const data,
  const UInt8 data_len, const BOOL send_to_peer_list, const UInt8 priority,
  const one_net_raw_did_t* const raw_dst, const UInt8 src_unit,
  const tick_t* const send_time_from_now, const tick_t* const expire_time_from_now);
#endif


// address functions
BOOL on_is_my_NID(const on_encoded_nid_t * const NID);
BOOL on_is_my_DID(const on_encoded_did_t * const DID);
BOOL did_is_broadcast(const UInt8* const did);
int enc_did_cmp(const on_encoded_did_t* const enc_did1, const on_encoded_did_t* const enc_did2);
BOOL on_encoded_did_equal(const on_encoded_did_t * const LHS,
  const on_encoded_did_t * const RHS);
one_net_status_t on_validate_dst_DID(const on_encoded_did_t * const DID);


// encryption functions
one_net_status_t on_encrypt(const UInt8 DATA_TYPE, UInt8 * const data,
  const one_net_xtea_key_t * const key, const UInt8 payload_len);
one_net_status_t on_decrypt(const UInt8 DATA_TYPE, UInt8 * const data,
  const one_net_xtea_key_t * const key, const UInt8 payload_len);

// packet reception functions
one_net_status_t on_rx_data_pkt(const on_encoded_did_t * const EXPECTED_SRC_DID,
  on_txn_t ** txn);

// functions to build packets
one_net_status_t on_build_nonces(UInt8 * const data, const UInt8 TXN_NONCE,
  const UInt8 RESP_NONCE);

one_net_status_t on_build_admin_pkt(UInt8 * pkt, UInt8 * const pkt_size,
  const UInt8 MSG_TYPE, const UInt8 MSG_ID,
  const on_encoded_did_t * const ENCODED_DST,
  const UInt8 TXN_NONCE, const UInt8 RESP_NONCE,
  const UInt8 * const RAW_DATA, const UInt8 DATA_LEN,
  const one_net_xtea_key_t * const KEY);
one_net_status_t on_build_data_pkt(UInt8 * pkt, UInt8 * const pkt_size,
  const UInt8 MSG_TYPE, const UInt8 PID,
  const on_encoded_did_t * const ENCODED_DST, const UInt8 TXN_NONCE,
  const UInt8 RESP_NONCE, const UInt8 * const RAW_DATA,
  const UInt8 DATA_LEN, const one_net_xtea_key_t * const KEY);
  
one_net_status_t on_build_response_pkt(UInt8 * pkt, UInt8 * const pkt_size,
   const UInt8 PID, const on_nack_rsn_t* const nack_reason, const on_ack_nack_handle_t* const ack_nack_handle,
   const ack_nack_payload_t* const ack_nack_payload,
   const on_encoded_did_t * const ENCODED_DST, const UInt8 TXN_NONCE,
   const UInt8 EXPECTED_NONCE, const one_net_xtea_key_t * const KEY,
   const on_data_t data_type);

#ifdef _DATA_RATE
one_net_status_t on_build_data_rate_pkt(UInt8 * pkt, UInt8 * const pkt_size,
  const on_encoded_did_t * const ENCODED_DST, UInt8 data_rate);
#endif
one_net_status_t on_build_pkt(UInt8 * pkt, UInt8 * const pkt_size,
  const UInt8 PID, const on_encoded_did_t * const ENCODED_DST,
  const UInt8 * const RAW_DATA, const UInt8 DATA_WORD_SIZE);


// functions to parse packets
one_net_status_t on_parse_pld(UInt8 * const txn_nonce, UInt8 * const resp_nonce,
  UInt8 * const msg_type, UInt8 * const pld, const UInt8 DATA_TYPE,
  const one_net_xtea_key_t * const KEY);
  
one_net_status_t on_parse_txn_pld(on_txn_t * const txn, UInt8 * const pld,
  const UInt8 DATA_TYPE, const one_net_xtea_key_t * const KEY);

#ifdef _BLOCK_MESSAGES_ENABLED
// transaction functions
void on_update_next_txn_time(on_txn_t * const txn);
#endif

// the main function
BOOL one_net(on_txn_t ** txn);

#if defined(_ONE_NET_DEBUG) 
    enum
    {
        ONE_NET_DEBUG_RF_WRITE = 1,
        ONE_NET_DEBUG_ONS_BAD_PKT_TYPE = 2,
        ONE_NET_DEBUG_NACK_WITH_RSN_TEST = 3,   // raw nonces and reason
        ONE_NET_DEBUG_NACK_WITH_RSN2_TEST = 4,  // encoded nonces and reason
        ONE_NET_DEBUG_NACK_WITH_RSN3_TEST = 5,  // txn nonce
        ONE_NET_DEBUG_NACK_WITH_RSN4_TEST = 6,  // response nonce
        ONE_NET_DEBUG_HANDLE_EXTENDED_ADMIN = 7,// status from handling extended admin
        ONE_NET_DEBUG_ONS_BAD_PARAM = 8,        // bad parameters passed toa function.
        ONE_NET_DEBUG_ONS_INTERNAL_ERR = 9,     // an internal error was detected
        ONE_NET_DEBUG_ONS_UNHANDLED_PKT = 10,   // unhandled packet
        ONE_NET_DEBUG_ONS_BAD_PKT = 11,         // bad packet
        ONE_NET_DEBUG_BUILD_RESP_PKT = 12       // status from on_build_response_pkt
    };

    void one_net_debug(UInt8 debug_type, UInt8 * data, UInt16 length);
#endif


//! @} ONE-NET_pub_func
//                      PUBLIC FUNCTION DECLARATIONS END
//==============================================================================

//! @} ONE-NET

#endif // _ONE_NET_H //

